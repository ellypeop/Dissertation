\documentclass{article}

\usepackage{titlesec}
\usepackage{graphicx} % Required for inserting images
\usepackage{biblatex} % Use biblatex for bibliography management
\usepackage{hyperref}

\addbibresource{mybib.bib} % Specify your bibliography file

\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
%\def\toclevel@paragraph{6}
\def\toclevel@subparagraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\title{Dissertation}
\author{Supervisor: Carlos A. Pérez-Delgado\\ Programme: MSc Computer Science (Artificial Intelligence) \\ Word Count: 6,731}
\date{December 3, 2024}

\begin{document}

\maketitle

\thispagestyle{empty} % Suppress page number on the title page

% Start page numbering from the next page
\newpage
\setcounter{page}{1}

\section*{Acknowledgments}
% Add the content of the Acknowledgements section here.
\newpage

\section*{Abstract}
% Add the content of the Abstract section here.
\newpage

% List of Figures
\listoffigures
\newpage

% List of Tables
\listoftables
\newpage

% List of Abbreviations (example)
\section*{List of Abbreviations}
\begin{itemize}
    \item AI - Artificial Intelligence
    \item CD - Class Diagram
    \item C-SE - Classical Software Engineering
    \item COBYLA - Constrained Optimization by Linear Approximation
    \item MSc - Master of Science
    \item NISQ - Noisy Intermediate-Scale Quantum
    \item OMG - Object Management Group
    \item OOP - Object-oriented programming
    \item POP - Procedure-oriented programming
    \item PUB - Primitive Unified Blocs
    \item SD - Sequence Diagram
    \item SDK - Software Development Kit
    \item SU(2) - Special Unitary Group of Degree 2
    \item Q-UML - Quantum Unified Modelling Language
    \item Q-SE - Quantum Software Engineering
    \item UML - Unified Modelling Language
    \item VQE - Variational Quantum Eigensolver
    % Add more abbreviations as needed
\end{itemize}
\newpage

\tableofcontents

\newpage

\section{Introduction}

\subsection{Problem Description and Incentive}

Quantum Software Engineering (Q-SE) is an emerging research field seeking to develop and standardise software engineering principles in quantum technologies. Many of these standards have been adapted from classical software engineering (C-SE), attempting to keep them as familiar as possible to C-SE whilst being able to distinguish that quantum and classical systems are two fundamentally different hardware. 

One area of interest in Q-SE is the adaptation of Unified Modeling Language (UML) to model quantum systems and illustrate their communication with classical systems. Two notable papers have introduced adaptations of UML for this purpose: \textit{"A Quantum Software Modeling Language"}\cite{Pérez-Delgado2022} and \textit{"Design of classical-quantum systems with UML"}\cite{Pérez-Castillo2022}. Both propose methodologies for incorporating quantum technologies into UML, aiming to broaden the scope of professionals who can contribute to the Q-SE field and promote early adoption of a standardised quantum modelling language whilst quantum technologies remain in relative infancy. 

The critical question is which quantum UML adaptation offers the best solution. This involves evaluating their effectiveness for modelling quantum systems, their suitability in real-world applications and their potential for widespread adoption. Additionally, should the industry favour full-scale UML modelling or another simplified modelling approach, and which of the two adaptations best accommodates an alternative design preference?

\subsection{Goals and Objectives}

This project aims to create and contrast UML diagrams using these two quantum UML approaches.

The first objective is to choose an appropriate real-world example as a starting point for the initial diagrams. The example chosen is the Variational Quantum Eigensolver (VQE), a hybrid quantum/classical algorithm. VQE is ideal for exploring how communication between quantum and classical machines can be represented in a modelling language, as it requires iterative interaction between a classical optimiser and a quantum circuit to find its solution. 

The second objective is to choose the most suitable UML diagrams to model the algorithm and compare quantum UML methods. A sequence diagram was selected because it is one of the most commonly used UML diagrams and illustrates the communication between quantum and classical modules throughout the VQE algorithm. In addition, class diagrams were included to provide a structural view of the algorithm, offering insights into the relationships and attributes of the system components.

The third objective is to determine a robust method for comparison and analysis. This will involve combining the author’s observations and following established guidance on good diagram design.

The final objective is to create multiple UML diagrams and explore other quantum applications. A key area of exploration will involve modelling fundamental quantum properties, such as entanglement and superposition, as suggested by the authors of the quantum UML literature: \textit{"Although the scope of the paper focuses on extending UML for quantum software, it
could be explored how to represent in UML other fundamental properties of quantum
computers (e.g., superposition, entanglement, etc.)"}{\cite{Pérez-Castillo2022}. This approach will enable the application of existing UML diagrams in new contexts or using additional diagram types to represent these properties.

\section{Literature Review}

\subsection{Background}

\subsubsection{Q-SE 2020}

The Quantum Software Engineering (Q-SE) 2020 workshop marked the first international gathering aimed at fostering a community around quantum software engineering, focusing on \textit{"devising methods, approaches, and processes to develop software for quantum programs efficiently and to ensure their correctness"}\cite{QSE2020}. Originally scheduled to be held in Seoul, South Korea, it was adapted to a virtual format due to the COVID-19 pandemic, running over two days in July 2020. This workshop was co-located with the 42nd International Conference on Software Engineering (ICSE 2020), providing a platform for interdisciplinary collaboration within quantum and software engineering communities.

At the close of Q-SE 2020's first day, Carlos A. Pérez-Delgado presented, \textit{“Towards a Quantum Software Modeling Language”}\cite{Perez-Delgado2020}, a paper co-authored with Héctor G. Pérez-González. The collaboration began when Pérez-González, an expert in software engineering, approached Pérez-Delgado about submitting a paper to the Q-SE 2020 workshop. By combining Pérez-Delgado's expertise in quantum computing and quantum information with Pérez-González's background in software engineering, the duo developed the concept of Q-UML, which applies UML diagrams to quantum technologies\cite{Towards}.

\subsubsection{UML}

Unified Modelling Language (UML) is a general-purpose modelling language that is an industry standard for designing and documenting software systems. It is \textit{"a consolidation of the best practices that have been established over the years in the use of modelling languages"}\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}.

Modelling languages use graphical or textual notation to abstract complex technical information, facilitating communication between technical and non-technical professionals involved in information systems. Just as a blueprint simplifies the construction process by visually representing a building’s structure, a modelling language provides an organised framework to convey the structure and interactions of software and hardware systems that work together to perform a task\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. Their primary function is establishing a high-level language governed by a defined set of frameworks and rules\cite{Modelinglanguagemean}.

The Unified Modeling Language (UML) framework is rooted in the object-oriented programming (OOP) paradigm. OOP is \textit{"a computer programming model that organises software design around data, or objects, rather than functions and logic."}\cite{TechTargetOOP} Whereas Procedure Orientated Programming (POP) breaks down a task into smaller functions, executing them in a strict order \cite{OOPPOP}, OOP encapsulates elements in a system as classes and objects which contain data (attributes) and behaviour (methods)\cite{MediumOOPPOP}. The OOP approach facilitates a more natural, modular understanding of computing tasks inspired by real-world concepts\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. As a small example, a \texttt{person} could be considered an instance (the object) of the class \texttt{Human}, inheriting shared attributes such as \texttt{Age} and \texttt{HairColour} with each instance holding a specific attribute value such as \texttt{Age = 32} and \texttt{HairColour = "blonde"}.

The development of the Object-Oriented Programming (OOP) paradigm is credited to the programming language SIMULA, which was introduced in 1962\cite{Simula}. OOP quickly gained traction in the decades that followed, leading to the development of widely used languages today, such as C++, Java, and Python\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. As OOP languages became more popular, there was an increasing demand for modelling languages to aid in their analysis and development. This surge in demand led to the creation of numerous modelling languages, each with its own notation, resulting in confusion and compatibility issues\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. In response, the need for a unified modelling language arose, culminating in the creation of UML. Developed through collaborative efforts by experts in the field, UML aimed to integrate the best practices from various modelling languages\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. Released in 1997, UML has since undergone several revisions, with the latest version, UML 2.5.1, released in 2017 and maintained by the Object Management Group (OMG)\cite{OMG_UML}.

There are 14 types of UML diagrams, classified into two main categories: structural and behavioural diagrams \cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. Structural diagrams provide a static view of a system's architecture, illustrating its components' composition and relationships. Behavioural diagrams represent the dynamic interactions between system components at runtime, demonstrating how elements communicate and evolve throughout their lifecycle. 

Two of the most widely used diagrams are the sequence diagram, which falls under the behavioural category, and the class diagram, which is part of the structural category.

\subsubsubsection{Sequence Diagram}

Sequence diagrams belong to a sub-category of interaction diagrams, which includes communication, timing, and interaction overview diagrams\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}.

Sequence diagrams model communication protocols between human and non-human entities. The horizontal axis represents the sequence of communication messages, while the vertical axis shows the timing of interactions. Each element in a sequence diagram is represented by a lifeline extending vertically, which may terminate if it is no longer required in the system. Messages are represented by arrows connecting elements at various stages of their lifecycle.

\subsubsubsection{Class Diagram}

The class diagram defines the data and object structures within a system\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. Each class is depicted as a rectangular element containing information about the attributes it holds and the operations it can perform or share. Interconnected edges represent relationships between other classes in the system. The class diagram provides an overview of the modelled system's structural architecture.

\subsubsection{Q-SE 2021}

The second Quantum Software Engineering (Q-SE) workshop, held virtually in June 2021, included a segment focused on modelling quantum systems\cite{QSE2021}. During this session, Luis Jiménez-Navajas presented the paper \textit{"Modelling Quantum Circuits with UML"}\cite{Pérez-Castillo2021}, co-authored with Ricardo Pérez-Castillo and Mario Piattini. The paper introduced the concept of creating a UML profile diagram that could incorporate a quantum domain, using the example of an activity diagram to model a quantum circuit\cite{Pérez-Castillo2021}. 

Pérez-Castillo and Piattini further expanded on this work and, in 2022, published the paper \textit{"Design of Classical-Quantum Systems with UML"}\cite{Pérez-Castillo2022} in the Springer May 2022 \textit{Computing} journal\cite{Computing2022}. They also served as editors for \textit{“Quantum Software Engineering”}\cite{serrano2022quantum}, also published by Springer, which included a revision of Pérez-Delgado's Q-UML work. The follow-up paper, \textit{“A Quantum Software Modeling Language”}\cite{Pérez-Delgado2022}, further developed Q-UML by introducing additional pictorial elements for modelling quantum components and establishing fundamental axioms and core design principles.

\textit{"Design of Classical-Quantum Systems with UML"}\cite{Pérez-Castillo2022} built upon earlier efforts to develop a quantum UML profile diagram by extending its application to multiple UML diagram types. Pérez-Delgado's work with Q-UML modelled Shor's algorithm in the context of a quantum computer exhibiting quantum advantage, while Pérez-Castillo and Piattini modelled hybrid information systems. These hybrid systems, which combine classical and quantum processors, are already operational and can be executed on existing quantum hardware.

\subsubsection{NISQ}

The Noisy Intermediate Scale Quantum (NISQ), known as the near-term quantum computer, employs qubits ranging from tens to hundreds. An NISQ device is sensitive to noise and requires error correction. We are currently in the NISQ era, which means quantum advantage has yet to be achieved.

Despite this, computations can still be performed on NISQ devices, with workloads typically split between classical and quantum computers. One such computation that can be accomplished through this hybrid approach is the Variational Quantum Eigensolver. 

\subsubsection{VQE}

The Variational Quantum Eigensolver (VQE) is a hybrid algorithm that leverages both quantum and classical devices to find the ground state of a given physical system. 

The algorithm starts with the physical system represented as a Hamiltonian and prepares a parametrised trial state called the ansatz. A quantum computer evaluates the ansatz by applying a quantum circuit to explore the parameter search space. A classical optimiser then adjusts the parameters in each iteration, guiding the quantum circuit’s search and gradually refining the ansatz until the algorithm converges on the lowest energy estimate, the ground state of the physical system.

\subsubsection{Qiskit}

Qiskit is an open-source software development kit (SDK) created by IBM to access and utilise their cloud-based quantum computing services. Implemented in Python, Qiskit provides tools and libraries for quantum programming and experimentation. The VQE algorithm represented in the sequence diagram is based on the implementation of VQE in Qiskit \cite{IBM2024}, which interacts directly with the IBM Quantum Platform.

\subsubsubsection{Qiskit and VQE}

IBM Quantum Learning provides online tutorials\cite{Tutorial} on implementing quantum algorithms utilising the Qiskit SDK. The UML diagrams created for this project were based on the tutorial to implement the VQE algorithm in Qiskit\cite{IBM2024}.

The instance \textbf{hamiltonian} is initialised from the class \textbf{SparsePauliOp} by calling the \textit{.from\_list()} method in its construction. The \textbf{hamiltonian} object is a classical representation of Pauli operators, where each operator is given as a string (e.g., "X", "Y", "Z", or "I" for identity). Pauli operators are 2×2 matrices corresponding to spin measurements along the x, y, and z axes\cite{DJORDJEVIC201229}. Each operator string specifies actions on individual qubits. The VQE tutorial uses a 2-qubit system, acting on pairs of Pauli strings referred to as operator terms. The tensor product of these pairs is assigned a coefficient (represented as a complex number in Python) that defines the strength of each operator term. The linear combination of these terms represents the system's total energy, the Hamiltonian. Only non-zero operators and coefficients are stored, resulting in a sparse representation of operator terms and the Hamiltonian as a whole to reduce computational expense.

The instance \textbf{ansatz} is initialised from the class \textbf{EfficientSU2} with the number of qubits \textbf{hamiltonian} holds passed to it in its construction. The \textbf{EfficientSU2} class provides a hardware-efficient classical representation of a quantum circuit capable of creating parametrised quantum states. The circuit comprises layers of single-qubit operations along with C-NOT gates, which entangle the qubits. The Qiskit documentation defines SU(2) as \textit{"the special unitary group of degree 2, its elements are 2×2 unitary matrices with determinant 1, such as the Pauli rotation gates"}\cite{EfficientSU2}, meaning that the circuit includes layers of operations that rotate the states of individual qubits, specifically using Pauli rotation gates. Each Pauli rotation gate holds a parameter which will be iteratively adjusted to find the lowest energy state of \textbf{ansatz}.

The instance \textbf{backend} is initialised from the class \textbf{QiskitRuntimeService}. The \textbf{QiskitRuntimeService} class interacts with the IBM Qiskit Runtime Service that provides cloud-based access to quantum hardware and quantum simulators. Creating an IBM account and giving a token when executing the code to access the service is necessary. The parameter \textbf{ibm\_quantum} is given to \textbf{backend} during its construction to access the quantum computing platform available on the IBM cloud service. The method \textit{least.busy()} is used to select the next available quantum hardware with the parameter \textbf{simulator} set to false to access the quantum hardware as opposed to a quantum simulator. 

\textbf{QiskitRuntimeService} will instantiate an \textbf{IBMBackend} object which interacts with the selected quantum hardware. The attribute \textbf{target} of the \textbf{IBMBackend} object is accessed and passed as a parameter to the instance \textbf{pm} of the \textbf{StagedPassManager} class, created using the \textit{generate\_preset\_pass\_manager()} method. This process allows the pass manager to receive information regarding the constraints of the selected quantum hardware.

The pass manager will \textit{"define a typical full compilation pipeline from an abstract virtual circuit to one that is optimized and capable of running on the specified backend"}\cite{StagedPassManager}. The \textit{.run()} method is executed on \textbf{pm} to transform \textbf{ansatz} to be compatible with the selected quantum hardware, with the newly transformed ansatz stored in a new variable \textbf{ansatz\_isa}. The \textit{.apply\_layout()} method is then called on \textbf{hamiltonian}, with \textbf{ansatz\_isa} passed as a parameter, to modify its layout to be compatible with the selected quantum hardware. The modified Hamiltonian is then stored as a new variable  \textbf{hamiltonian\_isa}.

A cost function method, defined as \textbf{cost\_func}, is constructed to facilitate access to quantum hardware. It accepts an estimator and the components of a primitive unified bloc (PUB) as its parameters. The PUB object comprises an array of initial guesses for the parameters of the ansatz, the \textbf{hamiltonian\_isa} given as a list, and the quantum circuit \textbf{ansatz\_isa}. These components form a tuple and are assigned to the variable \textbf{pub}, which is given as a parameter for the estimator object's \textit{.run()} method. 

When \textit{estimator.run()} is executed, the classical, parametrised \textbf{ansatz\_isa} circuit is transpiled into a quantum circuit that is compatible with the selected quantum hardware. It is then executed on the quantum computer provided through the IBM cloud service, preparing a quantum state based on its current parameters. The \textbf{hamiltonian\_isa} list, which represents the system's Hamiltonian, is applied to this prepared quantum state. This guides the estimator in computing the energy expectation value of the system being modelled through the \textbf{ansatz\_isa} circuit. Once the operation is complete, the \textit{.result()} method returns a container of PUB results\cite{PrimitiveResult}, with slicing used to access the estimated energy of the \textbf{ansatz\_isa}, which is stored in the variable \textbf{energy}.

A dictionary named \textbf{cost\_history\_dict} stores the parameter, iteration, and energy estimate each time the estimator's \textit{.run()} method is executed. Its initial values consist of a placeholder for the parameters, iteration set to zero and an empty list for the energy estimate, with each energy estimate being appended to the list per execution. Finally, the cost function method returns the value of the \textbf{energy} variable as its result after being called.

A random array of initial guess parameters, assigned to the variable \textbf{x0}, is constructed using NumPy’s constant $\pi$ and its \textit{random.random()} method. The code generates an array of random floating-point numbers, scaled to the range of [0,$\pi$2], to account for every quantum state that can be represented on the Bloch sphere. The \textbf{ansatz} attribute \textbf{num\_parameters} sets the size of the array, having been stored earlier in the variable \textbf{num\_params}, to match the number of parameters to assign to each of the Pauli rotation gates in the ansatz circuit. The \textbf{x0} array will be given to \textbf{cost\_func} as the parameters required for the \textbf{pub} variable and updated iteratively to find the set of parameters that produce the lowest energy estimate of the system.

The instance \textbf{session} is initialised from the class \textbf{Session} with \textbf{backend} passed as a parameter to configure it to the selected quantum hardware. The instance \textbf{estimator} is then initialised from the class \textbf{EstimatorV2} with \textbf{session} passed to the estimator's \textbf{mode} attribute. This estimator, which operates within \textbf{cost\_func}, uses \textbf{session} to execute computations on the specified quantum backend. Assigning a  \textbf{Session} object as the estimator's \textbf{mode} facilitates the grouping of iterative calls to the quantum computer\cite{Session} when \textit{estimator.run()} executes, efficiently managing the allocation of jobs to quantum resources.

The \textbf{estimator} is used to interact with Qiskit Runtime Estimator primitive service\cite{EstimatorV2}. Qiskit offers two primary primitives—"Estimator" and "Sampler"—designed to simplify foundational quantum tasks\cite{QiskitRuntime}. The estimator primitive is required to complete the VQE algorithm's purpose of estimating the energy of a system.

The instance \textbf{res} of the classical \textbf{Minimize} function from the SciPy package is initialised with the Constrained Optimization by Linear Approximation (COBYLA) method, which is used to minimise a scalar function. In this case, the scalar function is the \textbf{cost\_func} method, which returns a scalar energy estimate as a float. The parameters for \textbf{res} include the \textbf{cost\_func}, the initial guess array \textbf{x0} for the ansatz parameters, along with \textbf{ansatz\_isa}, \textbf{hamiltonian\_isa}, and \textbf{estimator}, all passed from \textbf{res} to \textbf{cost\_func} for execution. 

During the optimisation loop, \textbf{cost\_func} calculates and returns the energy estimate of \textbf{ansatz\_isa}, while \textbf{res} iteratively updates the parameters in \textbf{x0}, adjusting the ansatz's parameters to minimize the energy estimate. Each call to \textbf{cost\_func} invokes the \textit{estimator.run()} method and performs 10,000 shots on the quantum circuit before returning the energy estimate. The loop continues until the energy estimate converges to the lowest achievable value, representing the ground-state energy.

Upon completion of the optimisation loop, successful termination of the process is verified by comparing the solution parameter and evaluation count against the stored solution parameter and iteration count within \textbf{cost\_history\_dict} maintained by the \textbf{cost\_func} method. These results are then visualised using the matplotlib package, plotting a graph with the number of iterations on the x-axis and the energy estimates on the y-axis.

\subsection{Related Work}

\subsubsection{Q-UML}

Q-UML is a methodology for integrating quantum computing into the UML standard. The paper establishes a fundamental axiom and five core design principles to consider when designing a UML quantum extension. As the axiom asserts, while the design should adhere to classical standards as closely as possible, it must acknowledge the fundamental differences between classical and quantum hardware. The design principles describe when and how to label components in a diagram as classical or quantum.

In Q-UML, quantum elements are visually distinguished using bold font for textual labels and double lines for diagrammatic components. 

\subsubsection{Quantum UML Profile}

A quantum UML profile is an extension of UML designed explicitly for hybrid information systems incorporating classical and quantum software.

In UML, a profile is a structural diagram that extends the language to support domain-specific custom models. The quantum UML profile introduces a set of stereotypes, tagged values and constraints to represent quantum concepts. 

\section{Design and Implementation}
\subsection{Plant UML}

The initial version of the VQE sequence diagram was drafted using the Plant UML plugin for PyCharm, an open-source tool that enables users to generate UML diagrams from plain text.

To create the Q-UML version of the VQE sequence diagram, a combination of Plant UML and Lucidchart was used to include the double lines and bold text necessary to distinguish quantum components. However, for creating the quantum UML profile, Plant UML alone may suffice, as it should have the tools required to extend UML to represent quantum-specific elements. 

\subsection{Lucidchart}

Lucidchart is a web-based application that creates general-purpose diagrams, including UML diagrams, through a graphical user interface (GUI). It is used when creating Q-UML adaptations as it allows the customisation of elements to contain bold text and double lines necessary to distinguish quantum components. 

The first completed diagram is a PNG file created in Lucidchart. An attempt was made to keep it to a format similar to the Plant UML output. Consistency must be considered to ensure a fair comparison between both diagrams; therefore, even if the VQE quantum UML profile diagram can be reproduced in Plant UML alone, it may need to be translated into Lucidchart to ensure this consistency is upheld.

\subsection{UML Design Choice}

UML offers users flexibility in choosing the level of detail required to represent system information within a diagram. It is essential to strike a balance between including sufficient information for clarity and avoiding over-complication, as UML diagrams should provide a high-level abstraction of the system. This section outlines the general formatting principles applied to all UML diagrams in this project. Subsequent sections on the VQE sequence and class diagrams will delve into specific design choices and their underlying rationale. Much of the reference material for constructing these diagrams has been sourced from the book UML @ Classroom\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. 

All UML diagrams consist of a content area populated by boxes and edges, which together form the specific design of each diagram type. An optional framing element was included in the UML diagrams for this project, enclosing these components within a boundary. The frame header displays the namespace of the system the diagram represents\cite{UMLElementFrame}. For this project, the namespace "Variational Quantum Eigensolver" is used, with abbreviations indicating the type of diagram preceding it. 

A sequence and class diagram have been created to model Qiskit’s implementation of the VQE algorithm. Additional versions of these diagrams have been adapted to illustrate the QUML and Quantum UML Profile extensions.

\subsection{VQE Sequence Diagram}

The elements in the sequence diagram represent instances of classes from Qiskit’s implementation of the VQE algorithm. Each instance is depicted as a rectangle, with a dashed, vertical lifeline extending downward from its creation to connect to a duplicated element at the bottom of the frame, where all the system elements are aligned. The naming convention follows the format \textit{instance:Class}.

Message sequences are simplified where possible to illustrate the provision of an attribute from one instance to another or to illustrate an operation's execution. For example, the message \textit{.num\_qubits} passed from the \textbf{hamiltonian} to the \textbf{ansatz} could have been a sequence of messages where the \textbf{ansatz} first requests the \textbf{.num\_qubits} attribute from the \textbf{hamiltonian} and the \textbf{hamiltonian} provides it as a response message, depicted by a dashed line and open arrowhead. This is more accurate; however, it would result in an over-complicated diagram of many messages. 

All messages in the diagram are synchronous, pointing from a sender to a receiver. A synchronous message indicates that the message must be received before the sender can continue with any further instructions\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. For example, the instance \textbf{pm:PassManager} cannot execute its \textit{pm.run(ansatz)} message until \textbf{backend:QiskitRuntimeService} passes its constraints and optimisation level. A continuous line and a filled triangular arrowhead depict a synchronous message.

A decision was made to omit the creation of an explicit \textbf{IBMBackend} element in the sequence diagram, opting instead to show messages invoking this object as originating from \textbf{backend:QiskitRuntimeService}.
The naming convention effectively conveys that \textbf{QiskitRuntimeService} serves as a "backend" instance. Adding \textbf{IBMBackend} would introduce unnecessary complexity to the sequence diagram, where the emphasis is on message flow rather than object details. These specifics are more appropriately captured in the class diagram, where \textbf{IBMBackend} has been included.

The transformation of \textbf{hamiltonian} and \textbf{ansatz} to \textbf{hamiltonian\_isa} and \textbf{ansatz\_isa} is depicted by a destruction event; a red cross on the lifeline at the point where \textbf{hamiltonian} and \textbf{ansatz} are no longer used in the system.

Activation bars depict the activation of multiple elements within the diagram when an operation is executed\cite{creatley}. This occurs when the pass manager executes its \textit{run.()} method, the  \textbf{hamiltonian} executes \textit{apply\_layout(layout=ansatz\_isa.layout)} and the execution of both \textbf{cost\_func} and \textbf{res}. Multiple elements within the system must be active to execute these operations.

The diagram uses two \textit{loop} fragments and an \textit{alt} fragment. The loop fragment expresses a sequence that is repeatedly executed\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014} with a boundary encompassing the messages involved in the repeated sequence. In the VQE sequence diagram, an outer loop fragment depicts the repeated exchange of messages between \textbf{cost\_func} and \textbf{res} as they seek to find the lowest energy estimate. An inner loop fragment depicts the repeated runs of the quantum circuit when \textit{estimator.run()} is executed. The upper right corner of the fragment contains a heading of the fragments label and a description of how long the process executes; the outer loop running until \textbf{[lowest energy estimate found]} and the inner loop running \textbf{[10,000 shots]}. The response message from the estimator is shown outside of this loop, as it does not return a result after each shot but once the circuit has completed 10,000 shots. 

The alt fragment in UML represents alternative sequences\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. Here, it evaluates whether the results of the \textbf{cost\_history\_dict} match those from the completed minimisation routine. Based on the boolean outcome—true or false—it determines if the verification is successful or unsuccessful.

\subsubsection{SD QUML}

This diagram has been completed and is attached at the end of this report. It illustrates the sequence of messages between modules necessary to execute the VQE algorithm. 

Multiple Pauli operators define the Hamiltonian “sparsely” instead of creating a complete matrix. It acts upon two qubits at a time, and the qubits count is passed to the ansatz object. The ansatz is a circuit that creates a trial state for the experiment. 

These objects are transformed through a pass manager to be compatible with a quantum computer, the “backend”. This process does not require communication with the quantum hardware, as the information is held classically; therefore, the diagram does not depict these modules as quantum.

A session is created and configured to the same backend, passing multiple circuits to an estimator object while the session handles resource management. This estimator is a quantum object, depicted as such in the diagram, as it utilises quantum hardware to estimate the values of the quantum circuits. 

The methods \texttt{minimize} and \texttt{cost\_func} contain the estimator object and are also depicted as quantum. The \texttt{cost\_func} takes the Hamiltonian, ansatz, and parameters (initially a NumPy array of random values) and combines them into a new variable, \texttt{pub}, which is then given to the estimator object. The estimator executes 10,000 shots, defined during its creation, meaning the quantum circuit runs 10,000 times. This message is marked as a quantum message with \textbf{bold text}, indicating that the communication uses quantum hardware. The estimator then returns an energy estimate, converted to classical information before being received by the \texttt{cost\_func}, therefore depicted as a classical message.

The \texttt{cost\_func} method updates the parameters and records critical information in a \texttt{Dictionary} object per iteration. The \texttt{minimize} method, acting as an outer loop, receives the energy estimate and uses a classical optimiser (COBYLA) to guide the process into finding the lowest energy estimate.

The loop is completed once the energy estimate returned by \texttt{cost\_func} converges to the lowest energy estimate, and the parameters and iterations are verified with the \texttt{Dictionary} object. The final step involves plotting each iteration and energy estimate using the Matplotlib Python library.

\subsubsection{SD Quantum UML Profile}

This has yet to be completed and will be the next step in the process.

\subsection{VQE Class Diagram}

Packages group the imported Python libraries used to execute the VQE algorithm in Qiskit. Although the Qiskit SDK is more than a library, encompassing a collection of libraries alongside other utilities\cite{SheriefAbul-Ezz}, it is depicted as a single package for simplicity. Packages in UML are typically used for larger, more complex software systems\cite{VisualParadigm}; however, it was elected as a design choice to provide a clear visual of the required imports to run the algorithm. The design of a package element resembles the loop and alt fragments used in the sequence diagram, where each package's related elements are enclosed within its boundaries, with the name of the respective package found in its upper right-hand corner heading. The package \textbf{NumPy} is embedded within the Qiskit package—a design choice made to prevent overlapping edges rather than to imply a nested structure.

The class diagram elements, depicted as rectangles, illustrate the classes used in Qiskit’s VQE algorithm implementation, with each rectangle divided into three sections: namespace, attributes, and operations. A design choice was made to keep the same notation of \textit{instance:Class} for the namespace, as used in the sequence diagram. This notation is typically used in object diagrams. Class diagrams provide a static system view and typically only include the class name. In contrast, object diagrams capture the system at runtime and use either \textit{instance}, \textit{instance:Class} or \textit{:Class} as its naming convention\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. The decision to retain the instance in the notation is for clarity's sake, providing a minimal but effective indication of which class represents what aspect of the VQE algorithm by the instance name. Without an in-depth knowledge of Qiskit, it may be difficult to determine that \textbf{EfficentSU2} represents the ansatz or \textbf{SparsePauliOp} represents the Hamiltonian.

A design choice was also made to create a separate diagram for the \textbf{Minimize} class, distinct from the \textbf{CostFunction} class. Attempts to depict all class connections in a single diagram led to overlapping edges and clutter. The resulting diagram remains clear and readable by isolating \textbf{Minimize} and connecting it with simplified classes from the Qiskit package. The simplified classes are enclosed within the Qiskit package to indicate the part of the system to which they belong. The only simplified class not included is \textbf{CostFunction}, as it caused visual alignment issues. Since \textbf{CostFunction} is a user-defined method rather than a Qiskit class, it was decided to keep it outside the package in the minor diagram. Its meaning should still be evident within the complete diagram's context.

Only the attributes and methods relevant to the VQE algorithm are shown; additional attributes and methods documented in these classes have been omitted for clarity.

Some elements in the diagram, such as \textbf{Numpy.ndarray}, \textbf{CostFunction}, and \textbf{Dict}, are user-defined classes and therefore lack documentation detailing their attributes and operations. The variables and methods within these objects are presented directly as the attributes and operations of these elements in the diagram.

Each class attribute and method contains a visibility marker and it's name with the format "visbility\textbf{name:}". The visibility of all attributes and methods within the system is public, distinguished by the character +, meaning they are accessible to all other objects within the system\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. This was determined by none of the attributes or methods containing a leading underscore, which is the convention used in Python to define private attributes and methods\cite{Privacy}.

Class attributes contain their datatype with the format "visbility\textbf{name:} data type". Some class attributes also include multiplicities, which can be seen in the classes \textbf{SparsePauliOp}, \textbf{EfficientSU2}, \textbf{QiskitRuntimeService}, \textbf{EstimatorV2}, \textbf{Dict}, and \textbf{Pyplot}. Attribute multiplities are used in these classes to convey how many values the attribute can hold\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}, with [0...1] indicating either none or one value or [1...*] to indicate one or many values. Attributes where multiplicities are omitted are considered to have only one value. Attributes with multiplicities also have additional information as to whether the values can be duplicated with the terms "unique" or "non-unique" and whether the values must be in a fixed order with the terms "ordered" or "unordered"\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. The format for an attribute which contains all of these details is "visbility\textbf{name:} data type[multiplicity]\{duplication,order\}". When an attribute's data type is a tuple, such as the \textbf{pub} attribute in \textbf{CostFunction}, each item's name and data type are specified, with square brackets enclosing the entire tuple to indicate its structure. Attributes can contain multiple data types. For example, the \textbf{mode} attribute of \textbf{Estimatorv2} can be assigned other data types than just Session. The name of the data type used in the specific algorithm is used for clarity. Including attributes is optional, with some classes not requiring this information, such as \textbf{StagedPassManager} and \textbf{Session}. 

Class methods are shown with either empty parentheses if no parameter information is needed or with detailed parameter information listed within the parentheses. The data type of the returned value is provided after the parentheses. The typical notation for a method with parameter information is "visbility\textbf{name}(\textbf{parameter name:} parameter data type): returned data type. For methods returning tuples—such as the \textit{from\_list()} method in \textbf{SparsePauliOp}, the \textit{run()} method in \textbf{Estimator}, and the \textit{res()} method in \textbf{Minimize}—each item's name and data type are specified and enclosed in square brackets, mirroring the method's format in code. 
The methods \textit{plot()}, \textit{set\_xlabel()}, and \textit{set\_ylabel()} in the \textbf{Pyplot} class do not have a return data type, as they do not return a value. Instead, they update a Figure object by assigning relevant information. The final output, of type Figure, is produced when the \textit{draw()} method is executed. Some classes, like \textbf{CostFunction} and \textbf{Minimize}, are methods themselves. These classes include methods with the class instance name, indicating that the class can be executed as an operation. Including operations is optional, with some classes not requiring this information, such as \textbf{IBMBackend} and \textbf{Dict}. 

Relationships, known as associations, between classes, are depicted by the edges that join the rectangles of the diagram. Edges with a solid line and filled triangular arrowhead pointing from one class to another indicate a binary association, where one class can view the visible attributes and operations of another class, but not the other way round\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. For example, \textbf{Session} can view the attributes and operations of \textbf{QiskitRuntimeService}, but \textbf{QiskitRuntimeService} cannot view the attributes and operations of \textbf{Session}. The edges between \textbf{SparsePauliOp} and \textbf{EfficentSU2} do not have arrowheads, meaning they are bidirectional\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}; each class can view the other's attributes and operations. As we established earlier, all attributes and operations in the system are public and can technically be accessed by all objects. In the context of the VQE algorithm, the associations indicate which objects share and which objects receive information. Specifically, \textbf{SparsePauliOp} and \textbf{EfficientSU2} provide each other with information throughout the VQE algorithm. In contrast, \textbf{QiskitRuntimeService} provides information to \textbf{Session}, but \textbf{Session} does not provide information to \textbf{QiskitRuntimeService}.

The \textbf{IBMBackend} class depends on the \textbf{QiskitRuntimeService} class. This is depicted by a dashed line with an open arrowhead pointing from the dependent object to the object it depends on. The Qiskit documentation states that IBMBackend must not be instantiated directly and instead should be interacted with using the methods in \textbf{QiskitRuntimeService}\cite{IBMBackend}. The \textbf{IBMBackend} class is included in this diagram as its documentation contains the \textbf{target} attribute, which must be passed to \textbf{StagedPassManager} to access information regarding the selected quantum hardware constraints. The relationship has the stereotype \texttt{<<instantiate>>} as \textbf{IBMBackend} requires \textbf{QiskitRuntimeService} for it's full implementation\cite{Dependencyrelationships}

The class \textbf{Dict} is a composition of the class \textbf{CostFunction}. A composition is a binary association signifying that one class is contained as part of another class and cannot exist without it; if the aggregate(whole) object is destroyed, the contained part is also destroyed\cite{UMLComposition}. The relationship is depicted on the association edge by a filled diamond attached to the aggregate class. In this case, \textbf{Dict} is an integral part of \textbf{CostFunction} as it's written inside the method, remembering that the class \textbf{CostFunction} represents a user-defined method. If \textbf{CostFunction} were destroyed, \textbf{Dict} would also be destroyed.

Shared aggregation is similar to composition in that it signifies that one class belongs to another\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}. However, unlike a composition, the contained classes can exist outside the aggregated class. The relationship is depicted on the assocation edge by a hollow diamond attached to the aggregate class. Shared aggregation is used to depict classes that are passed as parameters to other classes in the VQE algorithm; \textbf{Numpy:ndarray}, \textbf{EfficentSU2}, \textbf{EstimatorV2}, and \textbf{SparsePauliOp} are all passed as parameters to \textbf{CostFunction} and therefore have shared aggregation. The classes along with \textbf{CostFunction} are also passed to \textbf{Minimize} as parameters and, therefore, have shared aggregation. 

Some associations may be given an association name with a reading direction indicated by a filled triangular arrowhead pointing from one class to another. This arrowhead signifies the flow of the association's action, helping to clarify the direction in which information or control is passed between the classes involved. For example, the association between \textbf{StagedPassManager} and \textbf{EfficientSU2} shows that the pass manager will transform the ansatz and not the other way around. Although the reading direction points in the same direction as the binary association in this example, it does not have to\cite{Seidl_Scholz_Huemer_Kappel_Duffy_2014}.

The relationships between the classes in the diagram are defined by multiplicities, which specify how many objects are involved in each association. For instance, the binary association between \textbf{StagedPassManager} and \textbf{EfficientSU2} demonstrates that one instance of \textbf{StagedPassManager} is associated with exactly one instance of \textbf{EfficientSU2}. Multiplicities in the diagram are either \textbf{1} or \textbf{1..*}, with the option to label shared attributes. In the case of the \textbf{Minimize} class, it shares between one and many values of the attribute \textbf{res.x}—which contains parameters it iteratively updates—with a single \textbf{Numpy.ndarray} object. Subsequently, \textbf{Numpy.ndarray} shares only one array object with \textbf{CostFunction}. The use of multiplicities conveys a single-instance relationship between \textbf{Numpy.ndarray} and \textbf{CostFunction} while showing that \textbf{Minimize} dynamically updates and shares multiple values of \textbf{res.x} to the \textbf{Numpy.ndarray} class.

\subsubsection{CD QUML}

\subsubsection{CD Quantum UML Profile}

\section{Results and Analysis}

\subsection{Author Observations}

My initial observations of the first diagram suggest that while the bold text and double lines used to distinguish quantum components are visible, they are more easily identifiable in examples provided in the Q-UML paper. This is likely due to the larger scope of the VQE sequence diagram and the fact that it is primarily composed of classical elements.
Additional design choices could be considered to better differentiate between classical and quantum components, although these would fall outside UML standards. For example, different colours could represent classical and quantum modules. This feature would only be readily available in applications like Lucidchart but could be incorporated with Plant UML by developing an extension.
Once the quantum UML profile version of the VQE sequence diagram is completed, more detailed observations and comparisons between the two diagrams will be possible.

\subsection{Diagram Literature}

Once both diagrams are completed, it will be crucial to consult relevant literature on effective diagram design to make an informed assessment. Research papers exploring good diagram design, particularly concerning UML, should be considered. An example of such work is the paper "Improving Information System Design: Using UML and Axiomatic Design" \cite{CAVIQUE2022103569}, which provides valuable insights into improving system information design.

\subsection{Polling}

An anonymous questionnaire should be developed to present both VQE sequence diagrams to professionals and researchers in quantum computing and software engineering. Ideally, multiple UML diagrams would be included. The questionnaire should ask participants about the clarity of the diagrams, their understanding of the content being depicted, and their overall observations on the application of UML to quantum technologies. Additionally, gathering information on the industry sectors respondents are associated with would be valuable, providing insight into the diversity of perspectives within the results.

\section{Conclusions}

The paper will conclude with an overall assessment of the advantages and disadvantages of each method. It will address whether the primary goal and all four main objectives were achieved. Additionally, there will be a discussion on whether UML is the most suitable approach for representing quantum systems or if a more general flowchart format might be more appropriate. This will include considering which method could be used in such a case. I assume that Q-UML would remain the most applicable, as the quantum UML profile is inherently based on UML formatting.

\section{Future Work}

Depending on whether the fourth objective is achieved, further exploration into modelling fundamental quantum concepts would be beneficial for evaluating the effectiveness of applying UML to quantum systems.
Plant UML is currently the most convenient tool for creating UML diagrams, as Lucidchart is significantly more labour-intensive. Developing an extension for Plant UML or other open-source tools like Mermaid to incorporate Q-UML formatting would be highly advantageous for future diagram creation. Such an extension would also increase the utility of this method, making it more accessible for continued exploration and broader adoption in the QSE field.

\section*{References}

\section{Bibliography}
\printbibliography

\section{Appendix}

\end{document}
